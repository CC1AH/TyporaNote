[TOC]

### 一. 介绍

 1. 概念：

    控制和管理调度资源，并提供接口和环境。在裸机之上，目标是对于硬件机器的拓展。

    

 2. 功能：

     1. 作为系统资源的管理者：处理机（CPU）管理，存储器管理，文件管理，设备管理

     2. 作为用户和计算机硬件间的接口：提供命令接口和程序接口。

        a. 命令接口：分为联机命令接口（同步执行每句指令，比如cmd的time指令）和脱机/批处理命令接口（异步执行批次指令，比如.bat文件）。

        b. 程序接口：只能通过用户程序间接使用的接口（比如.DLL的系统调用），一般，系统调用=广义调用=程序接口。

        3. GUI
        
           

 3. 基本特征：

    1. 并发：两个或者多个事件在同一时间间隔内发生，并行是指多个事件在同一时刻同时发生

    2. 共享：系统中的资源可以供多个并发执行的进程共同使用

       a. 互斥共享：同一时间段只允许一个进程使用

       *互斥访问的逻辑：顺序为进入区（上锁的阶段）；临界区（访问临界资源的代码） 退出区 （解锁的阶段）；剩余区；并遵守空闲让进，忙则等待，有限等待和让权等待原则（以后还会涉及，不再展开）*

       b. 同时共享：同一时间段允许多个进程使用

       并发和共享互为存在的条件

    3. 虚拟：把物理上的实体对应为若干逻辑上的对应物

       比如只有4G的内存可以支持运行内存总额大于4G软件同时运行（虚拟存储器和空分复用技术，以后会重点讲解）

    4. 异步：因为资源限制，进程执行不会一贯到底，而是不可预知的

       并发和共享是虚拟和异步的存在条件
       
       

 4. 发展和分类：

    1. 手工操作阶段

       处理速度快，输入输出极慢（人工输入打点带），资源利用率低。

    2. 单道批处理系统

       计算机依靠监督程序从磁带读入，提高了处理速度和资源利用率（就是一次处理许多指令），但是仍然是串行的。

    3. 多道批处理系统

       把多个磁带放进去。真正意义上的OS诞生，调度程序会调度所有输入磁带的执行，是最早的流水线（输入、计算、输出模块可以保证一直工作而不用一直等待）。缺点就是没有提供人机交互。整个作业过程是一个黑盒。

    4. 分时操作系统

       计算机以时间片为单位轮流为用户作业/服务，用户可以通过终端与计算机交互。但是没有任务优先级。

    5. 实时操作系统

       能够相应一些紧急的任务，不需要时间片排队，保证了及时性和可靠性。按照是否允许小的时间规定差异分为硬实时系统（飞控）和软实时系统（抢票）。

    6. 其他：网络OS 分布式OS 个人OS
    
       

### 二. 指令分类、中断和异常、系统调用

1. 指令和内核的分类：

   A 特权指令（处于核心态，往往是内核程序在负责运行该种指令，可以执行如内存清零等操作）

   B 非特权指令（处于用户态，不能执行特权指令）。

   一般的，临近硬件层次的内核负责的相关功能（时钟管理，中断管理和原语（一种特殊的程序，最接近硬件的具有原子性的程序，如设备驱动，CPU切换等）、【进程管理，存储器管理，设备管理】等）一般使用特权指令定义。一些操作系统并不把方括号内的功能放到内核中，我们称之为微内核，反之称之为大内核。

   微内核内核功能少维护方便，但是需要频繁切换两态，性能就相对低。各有优劣。

   

2. 两态判断：

   使用PSW（程序状态寄存器）中的某个位来判断是在 哪个态

   

3. 中断是什么：

   中断的本质是指发生即需要OS介入开展管理工作，流程是CPU收到计时部件发出的中断信号，切换为核心态由OS内核对中断进行处理，切换进程运行。

   **重复一遍，当中断发生，CPU立即进入核心态，当前进程立即停止运行。并由OS内核进行处理。并且，中断是用户态到核心态的唯一途径。**

   而核心态到用户态只需要执行设置PSW（程序状态字）的特权指令即可

   

4. 中断的分类

   A. 内中断-中断信号来源于CPU内部，也称为异常、例外、陷入。分为指令中断（系统调用）和强迫中断（硬件故障（缺页）或者软件中断（除以0））

   *也可以分为陷入（有意的，如系统调用），故障（如缺页），终止（不可恢复的错误）*

   B. 外中断-信号来源于CPU外部，狭义概念上的中断。包括外设请求（如IO）和人工干预（如用户终止）两方面。CPU在执行完每条指令之后都需要检查外部中断信号。如果检测到，需要保护被中断进程的CPU环境，之后根据中断信号类型转入中断处理程序，运行完成后恢复环境即可。

   

5. 系统调用

   OS面向用户的接口称为命令接口，那么**面向应用程序的接口则称之为程序接口，又称系统调用，它实现的是对资源的控制，必须在核心态完成**；凡是和资源相关的都需要使用系统调用，高级语言（如C）的某些库函数封装了系统调用，因此开发者系统调用往往使用这种形式

   ```
   //举例: write()
   编译执行汇编，将参数放入寄存器mov，之后执行trap指令int导致切换到核心态。
   ```

   因此核心态下唯一一个不能执行的指令是陷入指令

   

### 三. 进程-组织, 状态和控制

 1. 背景

    计算机中出现多道程序的数据存放和并发执行的需求。为准确找到各个程序的存放位置。操作系统为每个运行的程序配置称之为PCB（进程控制块）的数据结构，用来存放诸如程序代码位置之类的信息。

    

 2. 定义

    进程实体包括程序段（指令序列）、数据段、PCB，他被简称为进程（n）。创建和撤销进程，就是PCB的创消过程，**PCB是进程存在的唯一标志**。

    我们可以说，进程（v）是进程实体的运行过程，是程序的一次执行过程，是**系统资源分配的调度的基本单位**，它的核心特性在于**动态性**

    综上，进程拥有动态性 独立性 并发性 异步性 结构性

    

 3. PCB的组成

    进程描述信息（进程标识符PID和用户标识符UID）、 进程控制和管理信息（当前状态和优先级）、资源分配清单、处理机相关信息（各种寄存器值，用于恢复结果）

    

 4. 进程的组织

    多个进程间的组织方式分为两种类型

    链接方式-按照进程状态将PCB分为几个队列，OS持有指向各个队列的指针（比如执行指针、就绪队列指针、阻塞队列指针）

    索引方式-根据进程状态分为几个索引表，OS持有指向各个索引表的指针

    

 5. 进程的状态

    三种基本状态：运行态（处理机处理中）、就绪态（已经**拥有除了处理机（CPU）**外的所有资源）、阻塞态（所**需除处理机的其他资源**被其他响应占用）

    两种额外状态：创建态（资源分配和PCB初始化等）、终止态（资源等的释放中）

    **状态转换**

    ![三态](./img/三态.png)

    A. 运行态到阻塞态是主动行为（主动请求资源而未得），阻塞态到就绪态是被动行为（资源被他方释放）。

    B. 阻塞态和运行态不能直接转换。

    

 6. 进程的控制

    可以简单理解为进程状态间的转换。进程控制使用原语控制，**原语使用关中断指令和开中断指令（显然是特权指令）保证原子操作，因而它必然运行在核心态。**
    
    
    
 7. 控制原语的分类

    总体来说包括三类：***更新PCB中的信息（修改进程状态标志，保存运行环境到PCB，从PCB恢复运行环境）、将PCB插入队列、分配/回收资源***

    从时间来看分为创建原语、撤销原语、阻塞-唤醒原语(成对使用)、切换原语五种。详细内容参考进程的队列模型等理解，在这里不再多列。

    

    

### 四. 进程-通信、线程和调度

 1. 通信

    进程内存地址空间相互独立，一个进程不能直接访问另一个进程的地址空间。这破坏了独立资源分配的概念。OS为进程通信提供了**共享存储、管道通信

    A. 共享存储包括基于数据结构的存储和基于共享区的存储，前者规定了特定共享空间只能使用固定的数据结构。后者则有进程而不是OS决定数据形式和位置，运行较快。

    B. 管道指用于连接读写进程的一个读写文件，又名PIPE文件。**单管道是半双工的，各个进程必须互斥地访问管道，而且数据是一次性的**（意味者读进程同时只有一个）。

    C. 消息传递机制以格式化消息(Message)为单位，进程**通过OS提供的发送/接受消息两个原语进行数据交换**，间接通信的方式不会将消息直接挂到接受消息的缓冲队列，而是先发送到中间实体（称为信箱）

    

 2. 线程和线程模型

    线程**只是用于提升进程并发度的运行实体**，它的静态概念对应为线程调度块和线程ID，动态概念也有就绪、阻塞、运行的状态，和进程非常类似。线程是程序执行流的最小单位。从设计思想来说，线程和进程将资源和调度进行了单向解耦；从而达到同资源实体的内部调度专注于行为，大大节约了相关动作的开销。

    线程包括用户级线程（ULT，user level thread，由用户空间的线程库管理，OS不知道）和内核级线程（KLT，kenel level thread，由OS内核管理，用户不知道），实际处理中常常将N + d个用户级线程映射到N个内核级线程中，**这种映射规则引申出了多对一、一对一、多对多的多线程模型分类。其优缺点取决于两态切换和并发能力间的制衡**，容易理解。

    *段落2：同一进程内的不同线程可以运行在多核CPU的不同核上吗？*

    

 3. 调度的概念

    ---背景：处理机数量小于进程数量，需要确定进程使用处理机的先后顺序。

    ---调度层次：

    高级调度：**外存向内存的调入和调出，调入时建立PCB，调出时撤销PCB**，而重点在调入时机的管理（跑完了就调出）。

    中级调度：**内存向虚拟内存的调入和调出，将不能运行的进程调至外存等待，而PCB常驻内存，称为挂起状态**。提高内存利用率和吞吐量。显然，重点还是在于调入时机，其频率远比高级调度要高（虚拟内存的空间比较充足）。中级调度只是为了减轻系统负载

    Interval:

    包含挂起状态的七状态模型。出入点显然在中间的3个运行态。和高级调度的区别就是***PCB的位置***，和阻塞态的区别在于***进程映像的位置***。

    ![七态](.\img\七态.png)

    低级调度：**内存向CPU的调入和调出**。从就绪队列中选取进程，将处理机分配给他。一般在秒级别。

    总结：

    ![三种调度](.\img\三种调度.png)

    

 4. 进程调度（低级调度）的时机

    进程**主动（正常或异常终指，主动阻塞/IO.etc）或者被动放弃（时间片用完或紧急中断或高优先级进程进入就绪队列）处理机**。被动方式不允许的话称为非抢占方式，一般只适用于早期批处理系统。

    在处理中断时，或者在OS内核程序临界区（指访问临界资源的代码）中，或在原子操作过程（原语）中不能做调度切换。

    内核临界区限制的原因是**调度程序也需要访问资源，显然非内核临界区是可以访问的**。

    

 5. 调度算法

    A. 评价指标

    ​	---CPU利用率：忙碌时间/工作时间

    ​	---系统吞吐量：单位时间内完成作业的数量（道/秒）

    ​	---作业周转时间：作业提交到完成的时间（包括调度等待的时间），平均周转时间指作业周转时间和/作业数目；**带权周转时间指作业周转时间/作业实际运行的时间**（这个值显然>1）同样的还有平均带权周转时间；

    ​	---作业等待时间：作业等待处理机的时间之和，包括建立进程后的等待服务的时间和作业在外存后备队列中的等待时间；他是周转时间减去运行时间减去IO等服务时间

    ​	---响应时间：从用户提交请求到首次产生响应所用的时间；

    

    B. 早期批处理系统调度算法-不关心响应时间，不够现代

    ​	***注意考察的点： 思想、规则、作业调度还是进程调度、抢占还是非抢占、优缺点、是否会导致饥饿。阅读一定明确以上问题***

    ​	<font color="red">FCFS（先来先服务）</font>: **本着公平的思想，按照作业/进程到达的先后顺序依次调入内存，非抢占**。一般的，作业调度为就绪队列顺序，进程调度为挂起队列顺序（这里和以后普遍以作业为代表，以后的调度算法不提及进程）；公平简单且不会饥饿，但对后排短作业非常不利。

    ​	<font color='red'>SJF（短作业优先）</font>：**追求最小平均等待时间**，还是作业和进程（SP*[rocess]*F）调度都适用的算法。要求**为已到最短的作业先服务，默认非抢占**，抢占式版本称为**SRTN（最短剩余时间优先）; 唯一的区别在于每当有一个新的进程进入就绪队列的时候就要依最小判断进行抢占动作。**抢占方式的等待时间/周转表现又要优于SJF，但是显然会耗费更多的调度资源。对短作业有利，但可能产生长作业饥饿问题。

    ​	<font color='red'>HRRN（高响应比优先）</font>：**追求平均等待时间和要求服务时间的均衡。选择响应比最高的作业服务**（响应比 = 已等待时间 + 预计运行时间 / 预计运行时间），作业和进程调度都适用。从而解决了长作业饥饿的问题。**非抢占**。结合FCFS和SJF，使用计算资源更多但更公平。

    *举例：到达时间2s，预计运行时间4s、现在时刻为7s。则现在时刻响应比为 5 + 4 / 4 = 2.25*

    

    C.交互式系统调度算法

    ​	注意点和上个小节一样，区别在于等待时间和周转时间不再计算，只关注响应时间。

    ​	<font color='red'>RR（时间片轮转）</font>：公平的轮流为各个进程服务，轮流让各个进程执行一个时间片t0，由时钟中断控制。**只适用于进程调度（首先要在内存中存在），抢占式算法**。t0过大则退化为FCFS增大响应时间，太小则切换资源消耗大。t0的选择使得切换资源消耗小于1%。公平而响应快。但是没有优先级---

    ​	<font color='red'>PS（优先级调度）</font>：**每次选择优先级调度最高的算法，可以用于作业调度和进程调度，分为非抢占（默认）和抢占方式**，分别对应主动放弃处理机和到达时排挤（同SRTN）。可以保证偏好但是可能导致饥饿。

    ​	*就绪队列不仅只有一个。可以按照不同优先级进行组织。优先级包括静态和动态优先级。优先级的判定（比如sys > user，front > deamon, cal > io，动态优先级可以从公平和资源方面调整）*

    ​	<font color="red">多级反馈队列</font>：**用于进程调度的抢占式算法，短进程到达可能饥饿，但是公平响应快而且可以规定偏好**（平衡优秀）；设置多级就绪队列，队列优先级从高到底，时间片由小到大；
    
    ​	新进程到达先进入Q1队尾-按FCFS分配时间片。如用完时间片还未结束则放到下一级的队尾。
    
    ​	只有第k级队列空，才会为k+1级分配时间片；
    
    ​	被抢占的进程回到本列队尾。
    
    ​	如果最后一级还没跑完时间片，回到最后一级的队尾。
    
    *举例：第5s的运行状况*
    
    ![例题-多级反馈队列](.\img\例题-多级反馈队列.png)
    
    

### 五. 进程-互斥和其初步实现

 1. 同步概念

    同步：同步机制保证并发执行的进程**以可预知的顺序执行，是一种直接制约的关系**
    
    
    
 2. 进程互斥的软件实现方式

    A. <font color="red">单标志法</font>

    两个进程在访问完临界区后将权限交给另一个进程。**每个进程进入临界区的权限只能由另一个进程赋予**

    实例：

    ![互斥实现-单标志法](.\img\互斥实现-单标志法.png)

    缺点是违背空闲让进原则，临界区空闲时P0只要不进入便没有可以使用的

    B.  <font color="red">双标志先检查法</font>

    设置bool数组表示进入意愿（想要进入置为true）,检查是否有其他高优先级意愿，否则置true并访问，访问完后置false

    实例：

    ![互斥实现-双标志检查](.\img\互斥实现-双标志检查.png)

    C.  <font color="red">双标志后检查法</font>

    同B，但是检查在判断之后。同样的，如果按照下图1->5->2->6...会发生两者都无法进入临界区的情况，违背了空闲让进和有限等待原则:

    实例：

    ![互斥实现-双标志后检查](.\img\互斥实现-双标志后检查.png)

    我们发现，**进程的异步性是实现算法的最重要矛盾，尤其需要注意是否在进入区执行了非原子的操作，这很容易导致问题**，因此我们引入了下面这种算法：

    D.  <font color="red">Peteson算法</font>

    **同时设置意愿数组和优先度变量，前者同上，而后者用于安排进程表达不优先的意愿**。参考下面这个上厕所的例子。

    ![互斥实现-Peteson算法](.\img\互斥实现-Peteson算法.png)

    遵从了空闲让进，忙则等待，有限等待，但是没有遵守让权等待（不能进入临界区时没有立即释放处理机，而是在忙等待）

    

 3. 进程互斥的硬件实现方法

    A. <font color="red">中断屏蔽方法</font>

    关中断指令执行->临界区->开中断指令执行。不适用于多处理机和用户进程

    B. <font color="red">TSL/TS指令(TestAndSet)</font>

    **由硬件完成的指令，规定执行进程不可被中断**。实现互斥的算法逻辑非常简单，但是还是不满足让权等待（还是忙等待）：

    ```
    while(TestAndSet(&lock)); //上锁并检查被硬件变为了原子操作，因此解决了上面软件实现中的问题。
    //TS方法内部逻辑就是lock置为true, 之后返回原来传入的lock值
    critical section...
    lock = false;
    remainder section
    ```

    C. <font color="red">Swap指令</font>

    由硬件完成的指令，**交换两个值**，但是是原子的。和TS指令其实是一样的逻辑，缺点也一样：

    ```
    bool old = true;
    while(old == true)
    	Swap(&lock, &old);
    critial section
    lock = false;
    remainder section
    ```

    

4. 能不能不使用硬件方法，从而使得检查和上锁搞在一起呢？同时能不能解决让权等待问题呢？我们之后需要使用的就是信号量机制。



### 六. 进程-互斥的信号量实现、管程

 1. 信号量机制

    用户进程可以通过一对原语(wait、signal，称为PV操作)对信号量进行操作。从而实现进程互斥和同步。**信号量其实就是一个变量（整型或者记录形），往往用于标志资源的数量**

	2. 整型信号量S

    只能进行初始化、P操作、V操作三种动作。**不满足让权等待（while表示会出现忙等待）**

    ```
    wait(S):
    	while(S <= 0)
    		S--
    signal(S):
    	S++
    
    S = 10
    //when processes use resource S whose num is 10:
    wait(S) //进入区，亦可称为P(S)
    Operation Section
    signal(S) // 退出区, 亦可称为V(S)
    ```

	3. 记录型信号量semaphore

    使用记录型数据结构，没有资源时依托**block原语**将进程挂到信号量的阻塞队列中，使用完时**wakeup原语**唤醒队列中的某个进程，解决了让权等待的问题。**一定要val先变，因为原语的执行可能不是必要的**

    ```
    struct semaphore:
    	val //剩余资源数目
    	processQueue //等待队列，类型是struct process*
    wait(semaphore S):
    	S.val--
    	if(S.val < 0)
    		block(S.processQueue)
    signal(semaphore S):
    	S.val++
    	if(S.val <= 0) //说明等待队列里面有东西，<=0时代表队列里面有东西，唤醒操作才必要。
    		wakeup(S.processQueue)
    		
    S.val = 10
    //when processes use resource S whose num is 10:
    wait(S) //进入区
    Operation Section
    signal(S) // 退出区
    ```

	4. <font color="red">信号量机制实现互斥和同步</font>

    对于进程互斥，因为临界区同一时间只允许同一个进程访问，那么**临界区可以看成只有1数目的资源**。之后就是3的重复了。

    ```
    semaphore S = 1
    Px:
    	P(S)
    	critical Section
    	V(S)
    ```

    对于进程同步，设置同步信号量S = 0；在**前置操作之后执行V，后置操作之前执行P。简而言之就是等待前置操作释放资源（给出可操作信号）**。<font color="brown">**这种思想可以推广到使用信号量实现任意的前驱关系，对于依赖树的每一对前驱关系设置一个同步变量即可**</font>

    ```
    举例-代码4的执行依赖于代码段1和代码段2的顺序执行：
    P1:
    	para1 //front 
    	para2 //front
    	para3 
    P2:
    	para4 //back
    实现：
    semaphore S = 0
    P1:
    	para1 //front 
    	para2 //front
    	V(S)
    	para3 
    P2:
    	P(S)
    	para4 //back
    ```

    练习题：写出下列前驱操作树的伪代码。其中，s1->s6分别位于六个独立异步进程中。箭头发出点是被依赖的对象。你可以参考箭头上的黑字定义变量和操作，也可以无视他们。

    ​	![进程的前驱操作练习](.\img\进程的前驱操作练习.png)

	5. 

