[TOC]

### 一. 介绍

 1. 概念：

    控制和管理调度资源，并提供接口和环境。在裸机之上，目标是对于硬件机器的拓展。

    

 2. 功能：

     1. 作为系统资源的管理者：处理机（CPU）管理，存储器管理，文件管理，设备管理

     2. 作为用户和计算机硬件间的接口：提供命令接口和程序接口。

        a. 命令接口：分为联机命令接口（同步执行每句指令，比如cmd的time指令）和脱机/批处理命令接口（异步执行批次指令，比如.bat文件）。

        b. 程序接口：只能通过用户程序间接使用的接口（比如.DLL的系统调用），一般，系统调用=广义调用=程序接口。

        3. GUI
        
           

 3. 基本特征：

    1. 并发：两个或者多个事件在同一时间间隔内发生，并行是指多个事件在同一时刻同时发生

    2. 共享：系统中的资源可以供多个并发执行的进程共同使用

       a. 互斥共享：同一时间段只允许一个进程使用

       b. 同时共享：同一时间段允许多个进程使用

       并发和共享互为存在的条件

    3. 虚拟：把物理上的实体对应为若干逻辑上的对应物

       比如只有4G的内存可以支持运行内存总额大于4G软件同时运行（虚拟存储器和空分复用技术，以后会重点讲解）

    4. 异步：因为资源限制，进程执行不会一贯到底，而是不可预知的

       并发和共享是虚拟和异步的存在条件
       
       

 4. 发展和分类：

    1. 手工操作阶段

       处理速度快，输入输出极慢（人工输入打点带），资源利用率低。

    2. 单道批处理系统

       计算机依靠监督程序从磁带读入，提高了处理速度和资源利用率（就是一次处理许多指令），但是仍然是串行的。

    3. 多道批处理系统

       把多个磁带放进去。真正意义上的OS诞生，调度程序会调度所有输入磁带的执行，是最早的流水线（输入、计算、输出模块可以保证一直工作而不用一直等待）。缺点就是没有提供人机交互。整个作业过程是一个黑盒。

    4. 分时操作系统

       计算机以时间片为单位轮流为用户作业/服务，用户可以通过终端与计算机交互。但是没有任务优先级。

    5. 实时操作系统

       能够相应一些紧急的任务，不需要时间片排队，保证了及时性和可靠性。按照是否允许小的时间规定差异分为硬实时系统（飞控）和软实时系统（抢票）。

    6. 其他：网络OS 分布式OS 个人OS
    
       

### 二. 指令分类、中断和异常、系统调用

1. 指令和内核的分类：

   A 特权指令（处于核心态，往往是内核程序在负责运行该种指令，可以执行如内存清零等操作）

   B 非特权指令（处于用户态，不能执行特权指令）。

   一般的，临近硬件层次的内核负责的相关功能（时钟管理，中断管理和原语（一种特殊的程序，最接近硬件的具有原子性的程序，如设备驱动，CPU切换等）、【进程管理，存储器管理，设备管理】等）一般使用特权指令定义。一些操作系统并不把方括号内的功能放到内核中，我们称之为微内核，反之称之为大内核。

   微内核内核功能少维护方便，但是需要频繁切换两态，性能就相对低。各有优劣。

   

2. 两态判断：

   使用PSW（程序状态寄存器）中的某个位来判断是在 哪个态

   

3. 中断是什么：

   中断的本质是指发生即需要OS介入开展管理工作，流程是CPU收到计时部件发出的中断信号，切换为核心态由OS内核对中断进行处理，切换进程运行。

   **重复一遍，当中断发生，CPU立即进入核心态，当前进程立即停止运行。并由OS内核进行处理。并且，中断是用户态到核心态的唯一途径。**

   而核心态到用户态只需要执行设置PSW（程序状态字）的特权指令即可

   

4. 中断的分类

   A. 内中断-中断信号来源于CPU内部，也称为异常、例外、陷入。分为指令中断（系统调用）和强迫中断（硬件故障（缺页）或者软件中断（除以0））

   *也可以分为陷入（有意的，如系统调用），故障（如缺页），终止（不可恢复的错误）*

   B. 外中断-信号来源于CPU外部，狭义概念上的中断。包括外设请求（如IO）和人工干预（如用户终止）两方面。CPU在执行完每条指令之后都需要检查外部中断信号。如果检测到，需要保护被中断进程的CPU环境，之后根据中断信号类型转入中断处理程序，运行完成后恢复环境即可。

   

5. 系统调用

   OS面向用户的接口称为命令接口，那么**面向应用程序的接口则称之为程序接口，又称系统调用，它实现的是对资源的控制，必须在核心态完成**；凡是和资源相关的都需要使用系统调用，高级语言（如C）的某些库函数封装了系统调用，因此开发者系统调用往往使用这种形式

   ```
   //举例: write()
   编译执行汇编，将参数放入寄存器mov，之后执行trap指令int导致切换到核心态。
   ```

   因此核心态下唯一一个不能执行的指令是陷入指令

   

### 三. 进程-组织, 状态和控制

 1. 背景

    计算机中出现多道程序的数据存放和并发执行的需求。为准确找到各个程序的存放位置。操作系统为每个运行的程序配置称之为PCB（进程控制块）的数据结构，用来存放诸如程序代码位置之类的信息。

    

 2. 定义

    进程实体包括程序段（指令序列）、数据段、PCB，他被简称为进程（n）。创建和撤销进程，就是PCB的创消过程，**PCB是进程存在的唯一标志**。

    我们可以说，进程（v）是进程实体的运行过程，是程序的一次执行过程，是**系统资源分配的调度的基本单位**，它的核心特性在于**动态性**

    综上，进程拥有动态性 独立性 并发性 异步性 结构性

    

 3. PCB的组成

    进程描述信息（进程标识符PID和用户标识符UID）、 进程控制和管理信息（当前状态和优先级）、资源分配清单、处理机相关信息（各种寄存器值，用于恢复结果）

    

 4. 进程的组织

    多个进程间的组织方式分为两种类型

    链接方式-按照进程状态将PCB分为几个队列，OS持有指向各个队列的指针（比如执行指针、就绪队列指针、阻塞队列指针）

    索引方式-根据进程状态分为几个索引表，OS持有指向各个索引表的指针

    

 5. 进程的状态

    三种基本状态：运行态（处理机处理中）、就绪态（已经**拥有除了处理机（CPU）**外的所有资源）、阻塞态（所**需除处理机的其他资源**被其他响应占用）

    两种额外状态：创建态（资源分配和PCB初始化等）、终止态（资源等的释放中）

    **状态转换**

    ![三态](./img/三态.png)

    A. 运行态到阻塞态是主动行为（主动请求资源而未得），阻塞态到就绪态是被动行为（资源被他方释放）。

    B. 阻塞态和运行态不能直接转换。

    

 6. 进程的控制

    可以简单理解为进程状态间的转换。进程控制使用原语控制，**原语使用关中断指令和开中断指令（显然是特权指令）保证原子操作，因而它必然运行在核心态。**
    
    
    
 7. 控制原语的分类

    总体来说包括三类：***更新PCB中的信息（修改进程状态标志，保存运行环境到PCB，从PCB恢复运行环境）、将PCB插入队列、分配/回收资源***

    从时间来看分为创建原语、撤销原语、阻塞-唤醒原语(成对使用)、切换原语五种。详细内容参考进程的队列模型等理解，在这里不再多列。

    

    

### 四. 进程-通信、线程和调度

 1. 通信

    进程内存地址空间相互独立，一个进程不能直接访问另一个进程的地址空间。这破坏了独立资源分配的概念。OS为进程通信提供了**共享存储、管道通信

    A. 共享存储包括基于数据结构的存储和基于共享区的存储，前者规定了特定共享空间只能使用固定的数据结构。后者则有进程而不是OS决定数据形式和位置，运行较快。

    B. 管道指用于连接读写进程的一个读写文件，又名PIPE文件。**单管道是半双工的，各个进程必须互斥地访问管道，而且数据是一次性的**（意味者读进程同时只有一个）。

    C. 消息传递机制以格式化消息(Message)为单位，进程**通过OS提供的发送/接受消息两个原语进行数据交换**，间接通信的方式不会将消息直接挂到接受消息的缓冲队列，而是先发送到中间实体（称为信箱）

 2. 线程和线程模型

    线程**只是用于提升进程并发度的运行实体**，它的静态概念对应为线程调度块和线程ID，动态概念也有就绪、阻塞、运行的状态，和进程非常类似。线程是程序执行流的最小单位。从设计思想来说，线程和进程将资源和调度进行了单向解耦；从而达到同资源实体的内部调度专注于行为，大大节约了相关动作的开销。

    线程包括用户级线程（ULT，user level thread，由用户空间的线程库管理，OS不知道）和内核级线程（KLT，kenel level thread，由OS内核管理，用户不知道），实际处理中常常将N + d个用户级线程映射到N个内核级线程中，**这种映射规则引申出了多对一、一对一、多对多的多线程模型分类。其优缺点取决于两态切换和并发能力间的制衡**，容易理解。

    *段落2：同一进程内的不同线程可以运行在多核CPU的不同核上吗？*

 3. 调度的概念

    ---背景：处理机数量小于进程数量，需要确定进程使用处理机的先后顺序。

    ---调度层次：

    高级调度：**外存向内存的调入和调出，调入时建立PCB，调出时撤销PCB**，而重点在调入时机的管理（跑完了就调出）。

    中级调度：**内存向虚拟内存的调入和调出，将不能运行的进程调至外存等待，而PCB常驻内存，称为挂起状态**。提高内存利用率和吞吐量。显然，重点还是在于调入时机，其频率远比高级调度要高（虚拟内存的空间比较充足）。中级调度只是为了减轻系统负载

    Interval:

    包含挂起状态的七状态模型。出入点显然在中间的3个运行态。和高级调度的区别就是***PCB的位置***，和阻塞态的区别在于***进程映像的位置***。

    ![七态](.\img\七态.png)

    低级调度：**内存向CPU的调入和调出**。从就绪队列中选取进程，将处理机分配给他。一般在秒级别。

    总结：

    ![三种调度](.\img\三种调度.png)

 4. 进程调度（低级调度）的时机

    进程**主动（正常或异常终指，主动阻塞/IO.etc）或者被动放弃（时间片用完或紧急中断或高优先级进程进入就绪队列）处理机**。被动方式不允许的话称为非抢占方式，一般只适用于早期批处理系统。

    在处理中断时，或者在OS内核程序临界区（指访问临界资源的代码）中，或在原子操作过程（原语）中不能做调度切换。

    内核临界区限制的原因是**调度程序也需要访问资源，显然非内核临界区是可以访问的**。

 5. 调度算法

    A. 评价指标

    ​	---CPU利用率：忙碌时间/工作时间

    ​	---系统吞吐量：单位时间内完成作业的数量（道/秒）
    
    ​	---作业周转时间：作业提交到完成的时间（包括调度等待的时间），平均周转时间指作业周转时间和/作业数目；**带权周转时间指作业周转时间/作业实际运行的时间**（这个值显然>1）同样的还有平均带权周转时间；
    
    ​	---作业等待时间：作业等待处理机的时间之和，包括建立进程后的等待服务的时间和作业在外存后备队列中的等待时间；他是周转时间减去运行时间减去IO等服务时间
    
    ​	---响应时间：从用户提交请求到首次产生响应所用的时间；
    
    B. 早期批处理系统调度算法-不关心响应时间，不够现代
    
    ​	***注意考察的点： 思想、规则、作业调度还是进程调度、抢占还是非抢占、优缺点、是否会导致饥饿。阅读一定明确以上问题***
    
    ​	FCFS（先来先服务）: **本着公平的思想，按照作业/进程到达的先后顺序依次调入内存，非抢占**。一般的，作业调度为就绪队列顺序，进程调度为挂起队列顺序（这里和以后普遍以作业为代表，以后的调度算法不提及进程）；公平简单且不会饥饿，但对后排短作业非常不利。
    
    ​	SJF（短作业优先）：**追求最小平均等待时间**，还是作业和进程（SP*[rocess]*F）调度都适用的算法。要求**为已到最短的作业先服务，默认非抢占**，抢占式版本称为**SRTN（最短剩余时间优先）; 唯一的区别在于每当有一个新的进程进入就绪队列的时候就要依最小判断进行抢占动作。**抢占方式的等待时间/周转表现又要优于SJF，但是显然会耗费更多的调度资源。对短作业有利，但可能产生长作业饥饿问题。
    
    ​	HRRN（高响应比优先）：**追求平均等待时间和要求服务时间的均衡。选择响应比最高的作业服务**（响应比 = 已等待时间 + 预计运行时间 / 预计运行时间），作业和进程调度都适用。从而解决了长作业饥饿的问题。**非抢占**。结合FCFS和SJF，使用计算资源更多但更公平。
    
    *举例：到达时间2s，预计运行时间4s、现在时刻为7s。则现在时刻响应比为 5 + 4 / 4 = 2.25*
    
    C.交互式系统调度算法
    
    ​	注意点和上个小节一样
    
    ​	RR（时间片轮转）：
    
    

### 五. 进程-互斥和死锁

